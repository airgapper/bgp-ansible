{#

Common RPKI functions to use with BIRD

reject_rpki_invalid() - implicit arguments
    depends on these two functions:
        - complies_with_roa() - implicit arguments
    to be applied on each and every EBGP session

origin_to_roa(int asn)
    to be used to accept prefixes from an adjacent ASN
    if no IRR route object exists, but a valid ROA + announcement exist.
#}

{% for origin in origin_dict %}
define ROAS_AS{{ origin }} = [
        {% for prefix in origin_dict[origin] -%}
{%- if origin_dict[origin][prefix]['length'] == origin_dict[origin][prefix]['maxlength'] -%}
{{ prefix }}
{%- else -%}
{{ prefix }}{{ "{" }}{{ origin_dict[origin][prefix]['length'] }},{{ origin_dict[origin][prefix]['maxlength'] }}{{ "}" }}
{%- endif -%}
{%- if not loop.last -%},{%- endif -%}
{%- if loop.index % 4 == 0 and not loop.last -%}
{{ "\n        " }}
{%- else -%}
{{ " " }}
{%- endif -%}
{%- endfor -%}
    ];
{% endfor %}

roa table ROAS {
{%- for roa in roa_list %}
    roa {{ roa['p'] }} max {{ roa['m'] }} as {{ roa['o'] }};
{%- endfor -%}
}

function origin_to_roa(int asn)
{
    case asn {
{%- for origin in origin_dict|sort() if not origin == 0 %}
        {{ origin }}: return net ~ ROAS_AS{{ origin }};
{%- endfor %}
        else: return false;
    }
}

function reject_rpki_invalid()
{
    if (roa_check(ROAS, net, bgp_path.last_nonaggregated) = ROA_VALID) then {
        /* add rfc8097 marker to routes for which a valid matching ROA exists */
        bgp_ext_community.add((unknown 0x4300, 0, 0));
    }
    else if (roa_check(ROAS, net, bgp_path.last_nonaggregated) = ROA_INVALID) then {
        print "Reject: RPKI ROA check failed for ", net, " ", bgp_path, " protocol: ", proto;
        bgp_ext_community.add((unknown 0x4300, 0, 2));
        reject;
    }
    else {
        /* add rfc8097 marker to routes for which no covering ROA exists */
        bgp_ext_community.add((unknown 0x4300, 0, 1));
    }
}
